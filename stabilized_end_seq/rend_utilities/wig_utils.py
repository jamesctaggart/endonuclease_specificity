import math
from collections import OrderedDict, defaultdict
import numpy as np
from scipy.stats.mstats import winsorize
import pdb


def build_difference_matrix(A,B,abs=False):
    if abs == True:
        return np.abs(A[:, np.newaxis] - B)
    else:
        return A[:, np.newaxis] - B

def find_nearby_values(list1, list2, dist_thresh, symmetric=False):
    if symmetric == True:
        diff = build_difference_matrix(np.array(list1), np.array(list2), abs=True)
        return [(list1[x], list2[y]) for x,y in np.argwhere(diff <= dist_thresh)]
    elif symmetric == False:  # Use this if you only want to consider distances where one is larger than the other, but not the other way around.
        diff = build_difference_matrix(np.array(list1), np.array(list2), abs=False)
        return [(list1[x], list2[y]) for x,y in np.argwhere((diff <= dist_thresh) & (diff >= 0))]

def read_mochiview_reference(mochiview_annotaton_file, gene_only=False):

    '''
    Take mochiview Gene location set file as input and return dictionary of genes as output.
    Returns separate dicts per strand, which are formatted as {geneName:[start, end]}.
    Note that mochiview location set start/end is based on + strand coordinate (i.e. start is not 5' end for '-' strand)
    :param mochiview_annotaton_file: filename of mochiview Location Set (Genes) file.
    :return: tuple of plus strand genes and minus strand genes -> (plus_strand, minus strand)
    '''

    plusdict = OrderedDict()
    minusdict = OrderedDict()

    counter = 0
    with open(mochiview_annotaton_file, 'r') as f:
        for line in f:
            counter += 1
            if counter == 1:  # skip first line
                continue
            fields = line.split('\t')
            if len(fields) == 1:  # skip empty lines, which are just '\n'
                continue

            gene_name = fields[5]
            strand = fields[3]
            cdsstart = int(fields[10])
            cdsend = int(fields[11])
            
            gene_type = fields[6]

            if gene_type!='gene' and gene_only:
                continue

            if strand == '+':
                plusdict[gene_name] = (cdsstart, cdsend)
            elif strand == '-':
                minusdict[gene_name] = (cdsstart, cdsend)

    return plusdict, minusdict


def gene_from_position(position, strand, plus_dict, minus_dict):

    '''
    Given a position and strand, determine which gene it's in or nearest genes.
    Takes dicts generated by read_mochiview_reference as arguments.

    :param position: Position as int or float
    :param strand: strand of gene (accepts '+' or '-', or alternatively 0(for +) and 1(for -))
    :param plus_dict: Dictionary of plus strand genes ({geneName:[start, end]}, with smaller position as "start" regardless of strand, as per mochiview)
    :param minus_dict: Dictionary of minus strand genes ({geneName:[start, end]}, with smaller position as "start" regardless of strand, as per mochiview)
    :return: either gene name (meaning position within gene) or [(upstream_gene,distance),(downstream_gene,distance)] if intragenic
    '''


    if strand == 0:
        strand = '+'
    elif strand == 1:
        strand = '-'
    # Read the correct set of genes based on strand
    if strand == '+':
        refDict = plus_dict
    elif strand == '-':
        refDict = minus_dict

    # Initialize nearest upstream and downstream gene
    nearest_upstream = ('', 100000000)  # First value is gene name, second is distance to this gene
    nearest_downstream = ('', 100000000)

    # Iterate through the genes in our reference to see if any CDS contain position
    for gene in refDict:

        start = refDict[gene][0]  # Note that all starts and ends use + strand coordinates (i.e. not corrected to be start = 5' end)
        end = refDict[gene][1]

        if position > start and position < end:  # If position is within considered gene...
            return gene

        elif position < start and position < end:  # If position is upstream of considered gene...
            if start - position < nearest_downstream[1]:  # Check distance to gene to determine if this gene is closest
                nearest_downstream = (gene, start - position)
        elif position > start and position > end:  # If position is downstream of considered gene...
            if position - end < nearest_upstream[1]:# Check distance to gene to determine if this gene is closest
                nearest_upstream = (gene, position - end)

    ## If the position was not found to be part of a gene, return the nearest genes
    if strand == '+':
        return nearest_upstream, nearest_downstream
    elif strand == '-':
        return nearest_downstream, nearest_upstream


def wiggle_from_dict(reads_per_position, fh, chrom = 'NC_000964.3'):
    '''
    Given a dictionary which is key: position, values: read count
    Save a wiggle file with name fh
    :param reads_per_position: dictionary of form key: position, values: read count
    :param fh: file handle (wiggle is fh+'.wig')
    :return: None
    '''
    with open(fh,'w') as f:
        f.write('track type=wiggle_0' + '\n' + 'variableStep chrom=' + chrom + '\n')
        for position in sorted(reads_per_position.keys()):
            f.write(str(position)+'\t'+str(reads_per_position[position])+'\n')


def wiggle_to_dict(fh):
    '''
    Given a wiggle file with name fh
    Return a dictionary which is key: position, values: read count
    :param fh: file handle
    :return: Dictionary with key: position, value: read count
    '''
    wigDict = dict()

    with open(fh,'rU') as f:
        next(f) # Skip header
        next(f)
        for line in f:
            fields = line.split('\t')
            wigDict[int(fields[0])] = float(fields[1][:-1])

    return wigDict


def merge_wiggle(wig1, wig2, fh):
    '''
    Merge together two wiggle files, calculating sum at each position
    :param wig1: input wig 1
    :param wig2: input wig 2
    :param fh: file handle (wiggle is fh+'.wig')
    :return:
    '''
    val_per_pos = defaultdict(int)

    for wig in (wig1, wig2):
        with open(wig,'rU') as f:
            next(f)  # Skip 2 line long header of wiggle file
            next(f)
            for line in f:
                fields = line.split('\t')
                val_per_pos[int(fields[0])] += int(fields[1])

    wiggle_from_dict(val_per_pos, fh)


def runningMeanFast(x, N):
    '''
    Warning: this function has boundary issues at the end of the array
    '''
    return np.convolve(x, np.ones((N,))/N)[(N-1):]


def calculate_step(pos, strand, rc_array, window=50, gap=5, winsorization_level=0):
    if pos < gap+window:
        return np.nan
    if pos % 200000 == 0:
        print(pos, strand)
    if strand == '+':
        upstream=rc_array[pos-gap-window:pos-gap]
        downstream=rc_array[pos+gap:pos+gap+window]
    elif strand == '-':
        downstream=rc_array[pos-gap-window:pos-gap]
        upstream=rc_array[pos+gap:pos+gap+window]

    if winsorization_level>0:
        return np.mean(winsorize(np.array(downstream),winsorization_level))/np.mean(winsorize(np.array(upstream),winsorization_level))
    else:
        return np.mean(downstream)/np.mean(upstream)
    

def calculate_local_depth(pos, strand, rc_array, window=50, gap=5, winsorization_level=0, mode='both'):
    if pos < gap+window:
        return np.nan

    if strand == '+':
        upstream=rc_array[pos-gap-window:pos-gap]
        downstream=rc_array[pos+gap:pos+gap+window]
    elif strand == '-':
        downstream=rc_array[pos-gap-window:pos-gap]
        upstream=rc_array[pos+gap:pos+gap+window]

    if mode == 'both':
        full_window = downstream+upstream
    elif mode == 'up':
        full_window = upstream
    elif mode == 'down':
        full_window = downstream

    if winsorization_level>0:
        return np.mean(winsorize(np.array(full_window),winsorization_level))
    else:
        return np.mean(full_window)

def check_nearby_peak(position, reference_set, threshold, side='both'):
    '''
    side checks for peaks on both sides. left checks for peaks to left of position, right checks right of postion
    '''
    assert side in ('both','left','right')
    if side == 'both':
        for ref_pos in reference_set:
            if abs(position-ref_pos)<=threshold:
                return True
    elif side == 'right':
         for ref_pos in reference_set:
            if position>ref_pos:
                continue
            if abs(position-ref_pos)<=threshold:
                return True    
    elif side == 'left':
         for ref_pos in reference_set:
            if position<ref_pos:
                continue
            if abs(position-ref_pos)<=threshold:
                return True       
    return False

def sum_region(f_counts, r_counts, start, end, strand): # This implementation is much faster than looking in DataFrame
    if strand == '+':
        return sum(f_counts[start:end])
    elif strand =='-':
        return sum(r_counts[start:end])




